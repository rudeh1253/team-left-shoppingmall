package team.left.shoppingmall.global;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.function.Function;

import javax.sql.DataSource;

public class JdbcSupport {
    private static final DataSource dataSource = DataSourceContainer.getDataSource();
    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    private static final DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    
    private static final Map<Class<?>, Integer> JDBC_TYPE_PER_JAVA_TYPE;
    private static final Map<Integer, Class<?>> JAVA_TYPE_PER_JDBC_TYPE;
    
    private static final Map<Class<?>, Function<Object, Object>> CONVERTERS;
    
    private static final Map<Integer, Function<Object, Object>> REVERSE_CONVERTERS;
    
    static {
        Map<Class<?>, Integer> javaTypeAndSqlType = new HashMap<>();
        javaTypeAndSqlType.put(Integer.class, Types.NUMERIC);
        javaTypeAndSqlType.put(String.class, Types.VARCHAR);
        javaTypeAndSqlType.put(Date.class, Types.DATE);
        javaTypeAndSqlType.put(LocalDate.class, Types.DATE);
        javaTypeAndSqlType.put(LocalDateTime.class, Types.DATE);
        javaTypeAndSqlType.put(Boolean.class, Types.BOOLEAN);
        JDBC_TYPE_PER_JAVA_TYPE = Collections.unmodifiableMap(javaTypeAndSqlType);
        
        Map<Integer, Class<?>> javaTypePerJdbcType = new HashMap<>();
        javaTypePerJdbcType.put(Types.NUMERIC, Integer.class);
        javaTypePerJdbcType.put(Types.VARCHAR, String.class);
        javaTypePerJdbcType.put(Types.DATE, java.sql.Date.class);
        javaTypePerJdbcType.put(Types.TIMESTAMP, java.sql.Date.class);
        javaTypePerJdbcType.put(Types.TIME, java.sql.Date.class);
        javaTypePerJdbcType.put(Types.BOOLEAN, Boolean.class);
        javaTypePerJdbcType.put(Types.CHAR, String.class);
        JAVA_TYPE_PER_JDBC_TYPE = Collections.unmodifiableMap(javaTypePerJdbcType);
        
        Map<Class<?>, Function<Object, Object>> converters = new HashMap<>();
        converters.put(Integer.class, (o) -> o);
        converters.put(String.class, (o) -> o);
        converters.put(Date.class, (o) -> java.sql.Date.valueOf(dateFormat.format((Date) o)));
        converters.put(LocalDate.class, (o) -> java.sql.Date.valueOf(dateTimeFormatter.format((LocalDate) o)));
        converters.put(LocalDateTime.class, (o) -> java.sql.Date.valueOf(dateTimeFormatter.format((LocalDateTime) o)));
        converters.put(Boolean.class, (o) -> o);
        CONVERTERS = Collections.unmodifiableMap(converters);
        
        Map<Integer, Function<Object, Object>> reverseConverters = new HashMap<>();
        reverseConverters.put(Types.NUMERIC, (o) -> o);
        reverseConverters.put(Types.VARCHAR, (o) -> o);
        reverseConverters.put(Types.DATE, (o) -> {
            java.sql.Date date = (java.sql.Date) o;
            return LocalDate.of(date.getYear(), date.getMonth() + 1, date.getDate());
        });
        reverseConverters.put(Types.TIMESTAMP, (o) -> {
            java.sql.Date date = (java.sql.Date) o;
            return LocalDate.of(date.getYear(), date.getMonth() + 1, date.getDate());
        });
        reverseConverters.put(Types.TIME, (o) -> {
            java.sql.Date date = (java.sql.Date) o;
            return LocalDate.of(date.getYear(), date.getMonth() + 1, date.getDate());
        });
        reverseConverters.put(Types.BOOLEAN, (o) -> o);
        reverseConverters.put(Types.CHAR, (o) -> o);
        REVERSE_CONVERTERS = reverseConverters;
    }

    public static Map<String, Object> selectOne(String sql, Map<Integer, Object> params) {
        List<Map<String, Object>> result = query(sql, params);
        if (result.isEmpty()) {
            throw new NoSuchElementException("결과가 없습니다");
        }
        if (result.size() >= 2) {
            throw new IllegalArgumentException("결과 반환 결과가 2개 이상입니다.");
        }
        return result.get(0);
    }
    
    public static List<Map<String, Object>> selectList(String sql, Map<Integer, Object> params) {
        return query(sql, params);
    }
    
    public static int insertOne(String sql, Map<Integer, Object> params, String autogeneratedKeyColumn) {
        return update(sql, params, autogeneratedKeyColumn);
    }
    
    public static int insertOne(String sql, Map<Integer, Object> params) {
        return update(sql, params, null);
    }
    
    public static void update(String sql, Map<Integer, Object> params) {
        update(sql, params, null);
    }
    
    private static List<Map<String, Object>> query(String sql, Map<Integer, Object> params) {
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            conn = dataSource.getConnection();
            stmt = generatePreparedStatement(conn, sql, params, Optional.empty());
            
            rs = stmt.executeQuery();
            ResultSetMetaData rsmd = rs.getMetaData();
            
            List<Map<String, Object>> result = new ArrayList<>();
            
            while (rs.next()) {
                Map<String, Object> map = new HashMap<>();
                for (int i = 0; i < rsmd.getColumnCount(); i++) {
                    int colNum = i + 1;
                    String columnName = rsmd.getColumnName(colNum);
                    int jdbcType = rsmd.getColumnType(colNum);
                    
                    Object returnVal = rs.getObject(colNum, JAVA_TYPE_PER_JDBC_TYPE.get(jdbcType));
                    
                    map.put(columnName.toLowerCase(), REVERSE_CONVERTERS.get(jdbcType).apply(returnVal));
                }
                result.add(map);
            }
            return result;
        } catch (SQLException e) {
            throw new RuntimeException(e); // TODO
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    private static int update(String sql, Map<Integer, Object> params, String autogeneratedKeyColumn) {
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            conn = dataSource.getConnection();
            stmt = generatePreparedStatement(conn, sql, params, Optional.ofNullable(autogeneratedKeyColumn));
            
            int rows = stmt.executeUpdate();
            
            if (rows < 1) {
                throw new NoSuchElementException("결과 값이 없습니다");
            }
            
            if (autogeneratedKeyColumn == null) {
                return -1;
            }
            
            ResultSet generatedKeys = stmt.getGeneratedKeys();
            if (!generatedKeys.next()) {
                throw new NoSuchElementException("Key가 생성되지 않았습니다.");
            }
            
            return generatedKeys.getInt(1);
        } catch (SQLException e) {
            throw new RuntimeException(e); // TODO
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    private static PreparedStatement generatePreparedStatement(Connection conn, String sql, Map<Integer, Object> params, Optional<String> autogeneratedKeyColumn) throws SQLException {
        PreparedStatement stmt;
        if (autogeneratedKeyColumn.isPresent()) {
            stmt = conn.prepareStatement(sql, new String[] { autogeneratedKeyColumn.get() });
        } else {
            stmt = conn.prepareStatement(sql);
        }
        
        for (Map.Entry<Integer, Object> entry : params.entrySet()) {
            Integer colNum = entry.getKey();
            Object value = entry.getValue();
            if (value == null) {
                stmt.setObject(colNum, null);
                continue;
            }
            Class<?> valueType = entry.getValue().getClass();
            Function<Object, Object> converter = CONVERTERS.get(valueType);
            Integer sqlType = JDBC_TYPE_PER_JAVA_TYPE.get(valueType);
            
            if (converter == null || sqlType == null) {
                throw new UnsupportedDataTypeException("지원되지 않는 데이터 타입: " + valueType);
            }
            
            stmt.setObject(colNum, converter.apply(value), sqlType);
        }
        
        return stmt;
    }
}
